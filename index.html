<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alumni Globe - Real Earth Satellite Imagery</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0f0f23, #1a1a2e);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(79, 195, 247, 0.3);
        }
        
        #info h1 {
            font-size: 28px;
            margin-bottom: 15px;
            color: #4fc3f7;
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }
        
        #info p {
            font-size: 14px;
            opacity: 0.9;
            margin: 5px 0;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(79, 195, 247, 0.3);
        }
        
        .control-btn {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            border: none;
            color: white;
            padding: 10px 18px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.3);
        }
        
        .control-btn:hover {
            background: linear-gradient(45deg, #29b6f6, #0288d1);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(79, 195, 247, 0.5);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #4fc3f7;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top: 4px solid #4fc3f7;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 1000;
            font-size: 12px;
            border: 1px solid #4fc3f7;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            <p><strong>Loading Real Earth Imagery...</strong></p>
            <p>Fetching satellite textures and positioning alumni</p>
        </div>
        
        <div id="info">
            <h1>üåç Alumni Globe</h1>
            <p><strong>Real Satellite Imagery</strong></p>
            <p>üìç <strong>Alumni:</strong> <span id="alumniCount">0</span></p>
            <p>üåé <strong>Countries:</strong> <span id="countryCount">0</span></p>
            <p>üó∫Ô∏è <strong>Texture:</strong> <span id="textureStatus">Loading...</span></p>
        </div>
        
        <div id="controls">
            <button class="control-btn" onclick="toggleRotation()">‚è∏Ô∏è Pause</button>
            <button class="control-btn" onclick="resetView()">üîÑ Reset</button>
            <button class="control-btn" onclick="toggleLabels()">üè∑Ô∏è Labels</button>
            <button class="control-btn" onclick="changeTexture()">üåç Texture</button>
        </div>
        
        <div id="tooltip"></div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Global variables
        let scene, camera, renderer, globe, pointsGroup, raycaster, mouse;
        let isRotating = true;
        let showLabels = true;
        let currentTextureIndex = 0;
        let earthTextures = [];
        
        // Real Earth texture sources (high-quality satellite imagery)
        const textureUrls = [
            'https://unpkg.com/three-globe/example/img/earth-day.jpg',
            'https://unpkg.com/three-globe/example/img/earth-night.jpg',
            'https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/textures/planets/earth_atmos_2048.jpg',
            'https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/textures/planets/earth_clouds_1024.png'
        ];
        
        const textureNames = ['Day View', 'Night Lights', 'Atmospheric', 'Cloud Cover'];
        
        // Enhanced alumni data with more precise coordinates
        const alumniData = [
            { name: "John Smith", city: "New York", country: "USA", lat: 40.7128, lng: -74.0060, year: 2018, company: "Tech Corp" },
            { name: "Emma Johnson", city: "London", country: "UK", lat: 51.5074, lng: -0.1278, year: 2019, company: "Finance Ltd" },
            { name: "Hiroshi Tanaka", city: "Tokyo", country: "Japan", lat: 35.6762, lng: 139.6503, year: 2017, company: "Innovation Inc" },
            { name: "Maria Garcia", city: "Madrid", country: "Spain", lat: 40.4168, lng: -3.7038, year: 2020, company: "Design Studio" },
            { name: "David Brown", city: "Sydney", country: "Australia", lat: -33.8688, lng: 151.2093, year: 2016, company: "Mining Co" },
            { name: "Sophie Martin", city: "Paris", country: "France", lat: 48.8566, lng: 2.3522, year: 2019, company: "Fashion House" },
            { name: "Ahmed Hassan", city: "Cairo", country: "Egypt", lat: 30.0444, lng: 31.2357, year: 2018, company: "Heritage Org" },
            { name: "Priya Sharma", city: "Mumbai", country: "India", lat: 19.0760, lng: 72.8777, year: 2021, company: "Bollywood Studios" },
            { name: "Carlos Silva", city: "S√£o Paulo", country: "Brazil", lat: -23.5505, lng: -46.6333, year: 2017, company: "Coffee Exports" },
            { name: "Anna Petrov", city: "Moscow", country: "Russia", lat: 55.7558, lng: 37.6173, year: 2020, company: "Energy Systems" },
            { name: "James Wilson", city: "Toronto", country: "Canada", lat: 43.6532, lng: -79.3832, year: 2019, company: "Maple Tech" },
            { name: "Lisa Chen", city: "Singapore", country: "Singapore", lat: 1.3521, lng: 103.8198, year: 2018, company: "Port Authority" },
            { name: "Mohammed Al-Rashid", city: "Dubai", country: "UAE", lat: 25.2048, lng: 55.2708, year: 2021, company: "Desert Innovations" },
            { name: "Elena Rossi", city: "Rome", country: "Italy", lat: 41.9028, lng: 12.4964, year: 2016, company: "Archaeological Society" },
            { name: "Hans Mueller", city: "Berlin", country: "Germany", lat: 52.5200, lng: 13.4050, year: 2020, company: "Engineering GmbH" },
            { name: "Sarah O'Connor", city: "Dublin", country: "Ireland", lat: 53.3498, lng: -6.2603, year: 2019, company: "Green Energy" },
            { name: "Chen Wei", city: "Beijing", country: "China", lat: 39.9042, lng: 116.4074, year: 2018, company: "AI Research" },
            { name: "Fatima Al-Zahra", city: "Riyadh", country: "Saudi Arabia", lat: 24.7136, lng: 46.6753, year: 2020, company: "Oil & Gas" },
            { name: "Olaf Eriksson", city: "Stockholm", country: "Sweden", lat: 59.3293, lng: 18.0686, year: 2017, company: "Sustainable Tech" },
            { name: "Isabella Rodriguez", city: "Mexico City", country: "Mexico", lat: 19.4326, lng: -99.1332, year: 2021, company: "Cultural Heritage" }
        ];
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 2.5);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000011, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Initialize raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Load textures and create globe
            loadEarthTextures().then(() => {
                createRealisticGlobe();
                createAlumniPoints();
                addRealisticLighting();
                createStarField();
                updateStats();
                document.getElementById('loading').style.display = 'none';
                animate();
            });
            
            // Add mouse event listeners
            addMouseInteraction();
        }
        
        async function loadEarthTextures() {
            const loader = new THREE.TextureLoader();
            
            for (let i = 0; i < textureUrls.length; i++) {
                try {
                    const texture = await new Promise((resolve, reject) => {
                        loader.load(
                            textureUrls[i],
                            resolve,
                            undefined,
                            reject
                        );
                    });
                    
                    // Configure texture for proper Earth mapping
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    
                    earthTextures.push(texture);
                    
                    document.getElementById('textureStatus').textContent = 
                        `Loading ${i + 1}/${textureUrls.length}...`;
                        
                } catch (error) {
                    console.warn(`Failed to load texture ${i + 1}, using fallback`);
                    // Create fallback procedural texture
                    earthTextures.push(createFallbackTexture());
                }
            }
            
            document.getElementById('textureStatus').textContent = 'Ready';
        }
        
        function createFallbackTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Create realistic Earth colors
            const gradient = ctx.createLinearGradient(0, 0, 0, 1024);
            gradient.addColorStop(0, '#87CEEB'); // Sky blue (poles)
            gradient.addColorStop(0.2, '#228B22'); // Forest green
            gradient.addColorStop(0.4, '#32CD32'); // Lime green
            gradient.addColorStop(0.6, '#DAA520'); // Goldenrod (deserts)
            gradient.addColorStop(0.8, '#8B4513'); // Saddle brown
            gradient.addColorStop(1, '#4682B4'); // Steel blue (oceans)
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 2048, 1024);
            
            // Add continental shapes
            const continents = [
                // North America
                { x: 300, y: 300, w: 400, h: 300 },
                // South America  
                { x: 400, y: 600, w: 200, h: 350 },
                // Europe
                { x: 1000, y: 250, w: 200, h: 150 },
                // Africa
                { x: 1050, y: 400, w: 250, h: 400 },
                // Asia
                { x: 1300, y: 200, w: 500, h: 400 },
                // Australia
                { x: 1600, y: 700, w: 200, h: 100 }
            ];
            
            ctx.fillStyle = '#228B22';
            continents.forEach(continent => {
                ctx.fillRect(continent.x, continent.y, continent.w, continent.h);
            });
            
            return new THREE.CanvasTexture(canvas);
        }
        
        function createRealisticGlobe() {
            const geometry = new THREE.SphereGeometry(1, 128, 64);
            
            const material = new THREE.MeshPhongMaterial({
                map: earthTextures[currentTextureIndex],
                transparent: false,
                shininess: 100,
                specular: new THREE.Color(0x111111)
            });
            
            globe = new THREE.Mesh(geometry, material);
            globe.castShadow = true;
            globe.receiveShadow = true;
            scene.add(globe);
            
            // Add atmosphere
            createAtmosphere();
            
            // Add clouds layer
            createClouds();
        }
        
        function createAtmosphere() {
            const atmosphereGeometry = new THREE.SphereGeometry(1.005, 64, 64);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    c: { type: "f", value: 0.6 },
                    p: { type: "f", value: 6.5 }
                },
                vertexShader: `
                    uniform float c;
                    uniform float p;
                    varying float intensity;
                    void main() {
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * position);
                        intensity = pow(c - dot(vNormal, vNormel), p);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float c;
                    uniform float p;
                    varying float intensity;
                    void main() {
                        vec3 glow = vec3(0.3, 0.6, 1.0) * intensity;
                        gl_FragColor = vec4(glow, intensity * 0.8);
                    }
                `,
                side: THREE.FrontSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);
        }
        
        function createClouds() {
            if (earthTextures.length > 3) {
                const cloudGeometry = new THREE.SphereGeometry(1.003, 64, 64);
                const cloudMaterial = new THREE.MeshLambertMaterial({
                    map: earthTextures,[object Object],,
                    transparent: true,
                    opacity: 0.4
                });
                
                const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                scene.add(clouds);
                
                // Animate clouds
                const animateClouds = () => {
                    clouds.rotation.y += 0.001;
                    requestAnimationFrame(animateClouds);
                };
                animateClouds();
            }
        }
        
        function createAlumniPoints() {
            pointsGroup = new THREE.Group();
            
            alumniData.forEach((alumni, index) => {
                const point = createAlumniPoint(alumni, index);
                pointsGroup.add(point);
            });
            
            scene.add(pointsGroup);
        }
        
        function createAlumniPoint(alumni, index) {
            const group = new THREE.Group();
            
            // Convert lat/lng to 3D coordinates (proper spherical conversion)
            const phi = (90 - alumni.lat) * (Math.PI / 180);
            const theta = (alumni.lng + 180) * (Math.PI / 180);
            
            const radius = 1.008; // Slightly above surface
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            
            // Create main point
            const pointGeometry = new THREE.SphereGeometry(0.008, 16, 16);
            const pointMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL((index * 0.618034) % 1, 0.8, 0.6),
                emissive: new THREE.Color().setHSL((index * 0.618034) % 1, 0.3, 0.2),
                shininess: 100
            });
            
            const point = new THREE.Mesh(pointGeometry, pointMaterial);
            point.position.set(x, y, z);
            point.castShadow = true;
            
            // Create pulsing ring
            const ringGeometry = new THREE.RingGeometry(0.01, 0.015, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL((index * 0.618034) % 1, 0.8, 0.6),
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.set(x, y, z);
            ring.lookAt(0, 0, 0);
            
            // Create vertical beam
            const beamGeometry = new THREE.CylinderGeometry(0.001, 0.003, 0.05, 8);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL((index * 0.618034) % 1, 0.8, 0.8),
                transparent: true,
                opacity: 0.7
            });
            
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            beam.position.set(x * 1.025, y * 1.025, z * 1.025);
            beam.lookAt(x * 2, y * 2, z * 2);
            
            // Store alumni data for interaction
            point.userData = { 
                alumni, 
                originalPosition: { x, y, z },
                hovered: false
            };
            ring.userData = { alumni };
            beam.userData = { alumni };
            
            group.add(point);
            group.add(ring);
            group.add(beam);
            
            return group;
        }
        
        function addRealisticLighting() {
            // Remove default lighting
            scene.children = scene.children.filter(child => !(child instanceof THREE.Light));
            
            // Ambient light (space ambient)
            const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
            scene.add(ambientLight);
            
            // Sun light (directional)
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(5, 3, 5);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            // Rim light for atmosphere
            const rimLight = new THREE.DirectionalLight(0x4fc3f7, 0.3);
            rimLight.position.set(-5, 0, -5);
            scene.add(rimLight);
        }
        
        function createStarField() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8
            });
            
            const starsVertices = [];
            for (let i = 0; i < 15000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }
        
        function addMouseInteraction() {
            const tooltip = document.getElementById('tooltip');
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                // Check for intersections with alumni points
                const intersects = raycaster.intersectObjects(pointsGroup.children, true);
                
                // Reset all points
                pointsGroup.children.forEach(group => {
                    group.children.forEach(child => {
                        if (child.userData.alumni) {
                            child.scale.setScalar(1);
                            if (child.material.emissive) {
                                child.material.emissive.setHSL(0, 0, 0.1);
                            }
                        }
                    });
                });
                
                if (intersects.length > 0) {
                    const intersected = intersects,[object Object],object;
                    if (intersected.userData.alumni) {
                        // Highlight the point
                        intersected.scale.setScalar(1.5);
                        if (intersected.material.emissive) {
                            intersected.material.emissive.setHSL(0.1, 0.8, 0.4);
                        }
                        
                        // Show tooltip
                        const alumni = intersected.userData.alumni;
                        tooltip.innerHTML = `
                            <strong>${alumni.name}</strong><br>
                            üìç ${alumni.city}, ${alumni.country}<br>
                            üéì Class of ${alumni.year}<br>
                            üè¢ ${alumni.company || 'N/A'}
                        `;
                        tooltip.style.display = 'block';
                        tooltip.style.left = event.clientX + 10 + 'px';
                        tooltip.style.top = event.clientY + 10 + 'px';
                    }
                } else {
                    tooltip.style.display = 'none';
                }
            });
            
            renderer.domElement.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });
        }
        
        function updateStats() {
            document.getElementById('alumniCount').textContent = alumniData.length;
            const uniqueCountries = [...new Set(alumniData.map(a => a.country))];
            document.getElementById('countryCount').textContent = uniqueCountries.length;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate globe and points
            if (isRotating) {
                globe.rotation.y += 0.002;
                pointsGroup.rotation.y += 0.002;
            }
            
            // Animate point rings
            pointsGroup.children.forEach((group, index) => {
                const ring = group.children,[object Object],;
                if (ring) {
                    ring.rotation.z += 0.01 + index * 0.001;
                    const scale = 1 + 0.2 * Math.sin(Date.now() * 0.003 + index);
                    ring.scale.setScalar(scale);
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Control functions
        function toggleRotation() {
            isRotating = !isRotating;
            const btn = event.target;
            btn.textContent = isRotating ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
        }
        
        function resetView() {
            camera.position.set(0, 0, 2.5);
            camera.lookAt(0, 0, 0);
        }
        
        function toggleLabels() {
            showLabels = !showLabels;
            const btn = event.target;
            btn.textContent = showLabels ? 'üè∑Ô∏è Labels' : 'üè∑Ô∏è No Labels';
            // You can implement label showing/hiding logic here
        }
        
        function changeTexture() {
            if (earthTextures.length > 0) {
                currentTextureIndex = (currentTextureIndex + 1) % earthTextures.length;
                globe.material.map = earthTextures[currentTextureIndex];
                globe.material.needsUpdate = true;
                
                document.getElementById('textureStatus').textContent = 
                    textureNames[currentTextureIndex] || `Texture ${currentTextureIndex + 1}`;
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
